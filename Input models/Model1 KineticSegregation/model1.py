# -*- coding: utf-8 -*-
"""model1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_hND5poaSp4nMvq-dphxEb9BRQ1b8PYw
"""

!pip install arviz -q #==0.6.1
!pip install Theano==1.0.5 -q
!pip install pymc3==3.9.3 -q

import numpy as np
import scipy as sp
import pymc3 as pm
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import theano.tensor as tt
import scipy.stats as stats
import arviz as az
import logging
logger = logging.getLogger("pymc3")
logger.propagate = False

print('Running on PyMC3 v{}'.format(pm.__version__))
print('Running on ArviZ v{}'.format(az.__version__))

# defining colors for the diferent entities
TCR_color = np.array([0.0, 0.6, 0.0])
CD45_color = np.array([1.0, 0.0, 0.0])
LCK_color = np.array([0.0, 0.0, 0.4])
aLCK_color = np.array([1.0, 0.6, 1.0])
pTCR_color = np.array([1.0, 0.6, 0.0])
membrane_color = 0.6*np.array([1.0, 1.0, 1.0])

"""# Model 1 - kinetic segregation
#### Generate evidence

"""

### Model 1 - kinetic segregation (KS) #########################################
### t
Nt = 21
t = np.linspace(0, 100, Nt)

### k
Nk = 26
k = np.linspace(0, 50, Nk)

### kt_array
k_array, t_array = np.meshgrid(k,t)

### dm CD45 KS
at_dm_CD45 = 5 #0.6 # t slope
ak_dm_CD45 = 10 #1 # k slope
b_dm_CD45 = 0 # intercept
dm_CD45_array0 = b_dm_CD45 + at_dm_CD45*t_array + ak_dm_CD45*k_array

# add noise
dm_CD45_array = sp.ndimage.gaussian_filter(\
    dm_CD45_array0 + 10*np.random.randn(t_array.shape[0],t_array.shape[1]), sigma=0.5)

"""#### Build untrained model"""

def get_model1_untrained(t_array, k_array, dm_CD45_array): #dm_CD45_KS_obs
    '''
    TODO: add proper documentation

    '''
    model1 = pm.Model()
    with model1:
        ### model1 - KS (kinetic segregation) ###########################    
        # dw_TCR_KS #####################################################
        
        t_input = t_array.reshape(-1)
        k_input = k_array.reshape(-1)
        rv_t = pm.Uniform('rv_t', 0, 100, observed=t_input)
        rv_k = pm.Uniform('rv_k', 0, 50, observed=k_input)
        # rv_t = pm.Uniform('rv_t', 0, 100)
        # rv_k = pm.Uniform('rv_k', 0, 50)
        # dm_CD45_KS ####################################################
        dm_CD45_KS_obs = dm_CD45_array.reshape(-1)
        
        rv_at_dm_CD45_KS = pm.Normal('rv_at_dm_CD45_KS', mu=0, sd=1) # surface t slope
        rv_ak_dm_CD45_KS = pm.Normal('rv_ak_dm_CD45_KS', mu=10, sd=3) # surface k slope
        rv_b_dm_CD45_KS = pm.Normal('rv_b_dm_CD45_KS', mu=0, sd=20) # surface intercept
        rv_noise_dm_CD45_KS = pm.HalfNormal('rv_noise_dm_CD45_KS', sd=20) # noise 
        
        rv_dm_CD45_KS = pm.Normal('rv_dm_CD45_KS', mu=rv_b_dm_CD45_KS +\
                                    rv_at_dm_CD45_KS*rv_t + rv_ak_dm_CD45_KS*rv_k, \
                                    sd=rv_noise_dm_CD45_KS, observed=dm_CD45_KS_obs) #
    return model1

model1= get_model1_untrained(t_array, k_array, dm_CD45_array) #dm_CD45_KS_obs
gv1 = pm.model_to_graphviz(model1)
gv1

# from google.colab import files
# gv1.render("model1_graph", format="png")
# files.download("model1_graph.png") # Download locally from colab

# np.save("trained_Zs_mean", Zs_mean)
# np.save("trained_Zs_std", Zs_std)
# !ls
# from google.colab import files
# files.download("trained_Zs_mean.npy") # Download locally from colab
# files.download("trained_Zs_std.npy") # Download locally from colab

"""## Train model:"""

with model1:
    trace1 = pm.sample(2000, chains=2)

pm.traceplot(trace1);

pm.summary(trace1).round(3)

"""## Sanity check - validate in the form of a regression"""

rv_at_dm_CD45_KS_mean = trace1.rv_at_dm_CD45_KS.mean()
rv_ak_dm_CD45_KS_mean = trace1.rv_ak_dm_CD45_KS.mean()
rv_b_dm_CD45_KS_mean = trace1.rv_b_dm_CD45_KS.mean()
rv_noise_dm_CD45_KS_mean = trace1.rv_noise_dm_CD45_KS.mean()

dm_CD45_KS_post = rv_b_dm_CD45_KS_mean +\
                  rv_at_dm_CD45_KS_mean*t_array +\
                  rv_ak_dm_CD45_KS_mean*k_array


### plot #######################################################################
fig, ax0 = plt.subplots(1,2, figsize=[7, 3])

vmin2 = 0; vmax2 = 1000
im0 = ax0[0].pcolor(t_array, k_array, dm_CD45_array, vmin=vmin2, vmax=vmax2)
ax0[0].contour(t_array, k_array, dm_CD45_array, vmin=vmin2, vmax=vmax2, colors='w')
fig.colorbar(im0, ax=ax0[0])
ax0[0].set_title('$dm_{CD45}^{KS} (evidence)$')
ax0[0].set_xlabel('$t^{KS}(sec)$')
ax0[0].set_ylabel('$\kappa^{KS}(K_BT/nm)$')


im0 = ax0[1].pcolor(t_array, k_array, dm_CD45_KS_post, vmin=vmin2, vmax=vmax2)
ax0[1].contour(t_array, k_array, dm_CD45_KS_post, vmin=vmin2, vmax=vmax2, colors='w')
fig.colorbar(im0, ax=ax0[1])
ax0[1].set_title('$dm_{CD45}^{KS}$ (sanity check)')
ax0[1].set_xlabel('$t^{KS}(sec)$')
ax0[1].set_ylabel('$\kappa^{KS}(K_BT/nm)$')

plt.tight_layout();

# pm.plot_posterior(trace1)

# pm.model.unobserved_RVs
model1.model.vars

"""## Build trained model (with updated parameter estimates through their posteriors):"""

def get_model1_trained(trace1, observed_t= None, observed_k=None):
    ''' return model1 trained based on trace1. 
    If observed_t and/or observed_k are specified, 
    return the model conditioned on those values '''
    model1_trained = pm.Model()
    with model1_trained:
        ### model1 - KS (kinetic segregation) ###########################    
        # dw_TCR_KS #####################################################
        
        t_input = t_array.reshape(-1)
        k_input = k_array.reshape(-1)
        rv_t = pm.Uniform('rv_t', 0, 100, observed=observed_t)
        rv_k = pm.Uniform('rv_k', 0, 50, observed= observed_k)

        # dm_CD45_KS ####################################################
        # TO DO: remove surr
        dm_CD45_KS_obs = dm_CD45_array.reshape(-1)
        rv_at_dm_CD45_KS = pm.Normal('rv_at_dm_CD45_KS', 
                                    mu= trace1.rv_at_dm_CD45_KS.mean(), 
                                    sd= trace1.rv_at_dm_CD45_KS.std()) # surface t slope
        rv_ak_dm_CD45_KS = pm.Normal('rv_ak_dm_CD45_KS', 
                                    mu= trace1.rv_ak_dm_CD45_KS.mean(), 
                                    sd= trace1.rv_ak_dm_CD45_KS.std()) # surface k slope
        rv_b_dm_CD45_KS = pm.Normal('rv_b_dm_CD45_KS', 
                                    mu= trace1.rv_b_dm_CD45_KS.mean(), 
                                    sd= trace1.rv_b_dm_CD45_KS.std()) # surface intercept
        rv_noise_dm_CD45_KS = pm.HalfNormal('rv_noise_dm_CD45_KS', 
                                            sd= trace1.rv_noise_dm_CD45_KS.std()) # noise 
        
        rv_dm_CD45_KS = pm.Normal('rv_dm_CD45_KS', 
                                    mu=rv_b_dm_CD45_KS +\
                                        rv_at_dm_CD45_KS*rv_t + rv_ak_dm_CD45_KS*rv_k, 
                                    sd=rv_noise_dm_CD45_KS) #

    return model1_trained

model1_trained= get_model1_trained(trace1)
gv1 = pm.model_to_graphviz(model1_trained)
display(gv1)

"""## Test trained model for different values of k and t"""

n_t = 21 #11
n_k = 21 #11
Ts= np.linspace(0,100, n_t)
Ks= np.linspace(0, 50, n_k)
Zs_mean= np.zeros((n_t, n_k))
Zs_std= np.zeros((n_t, n_k))

logger = logging.getLogger("pymc3")
logger.propagate = False
for i,t in enumerate(Ts):
    for j,k in enumerate(Ks):
        cur_model= get_model1_trained(trace1, observed_k= k, observed_t= t)
        with cur_model:
            cur_trace = pm.sample(200, chains=1, progressbar = False);
        display.clear_output
        # display(f"i,t={i,t}, j,k={j,k}")
        print(f"i,t={i,t}, j,k={j,k}")
    #     display(pm.summary(cur_trace).round(3))
        Zs_mean[i,j]= cur_trace.rv_dm_CD45_KS.mean() 
        Zs_std[i,j]= cur_trace.rv_dm_CD45_KS.std();

np.save("trained_dm_CD45_KS_mean_21x21", Zs_mean)
np.save("trained_dm_CD45_KS_std_21x21", Zs_std)
!ls

from google.colab import files
files.download("trained_dm_CD45_KS_mean_21x21.npy") # Download locally from colab
files.download("trained_dm_CD45_KS_std_21x21.npy") # Download locally from colab

fig, ax0 = plt.subplots(1,3, figsize=[10, 3])

vmin2 = 0; vmax2 = 1000
im0 = ax0[0].pcolor(t_array, k_array, dm_CD45_array, vmin=vmin2, vmax=vmax2)
ax0[0].contour(t_array, k_array, dm_CD45_array, vmin=vmin2, vmax=vmax2, colors='w')
fig.colorbar(im0, ax=ax0[0])
ax0[0].set_title('$dm_{CD45}^{KS}$ (evidence)')
ax0[0].set_xlabel('$t^{KS}(sec)$')
ax0[0].set_ylabel('$\kappa^{KS}(K_BT/nm)$')


im1 = ax0[1].pcolor(t_array, k_array, dm_CD45_KS_post, vmin=vmin2, vmax=vmax2)
ax0[1].contour(t_array, k_array, dm_CD45_KS_post, vmin=vmin2, vmax=vmax2, colors='w')
fig.colorbar(im1, ax=ax0[1])
ax0[1].set_title('$dm_{CD45}^{KS}$ (sanity check)')
ax0[1].set_xlabel('$t^{KS}(sec)$')
ax0[1].set_ylabel('$\kappa^{KS}(K_BT/nm)$')


im2 = ax0[2].pcolor(Ts, Ks, Zs_mean, vmin=vmin2, vmax=vmax2)
ax0[2].contour(Ts, Ks, Zs_mean, vmin=vmin2, vmax=vmax2, colors='w')
fig.colorbar(im2, ax=ax0[2])
ax0[2].set_title('$dm_{CD45}^{KS}$ (trained)')
ax0[2].set_xlabel('$t^{KS}(sec)$')
ax0[2].set_ylabel('$\kappa^{KS}(K_BT/nm)$')
plt.tight_layout();

!ls